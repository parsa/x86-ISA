<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" type="text/css" href="../assets/style.css" />
<title>CVTPD2PS: Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values (x86 Instruction Set Reference)</title>
<link rel="icon" type="image/ico" href="favicon.ico" />
<meta name="keywords"
content="assembly,asm,programming,optimization,optimisation,c,c++,x86,pastebin,opcode,opcodes,dictionary,intel,amd,download,downloads,tutorial" />
<meta name="description"
content="x86 assembly tutorials, x86 opcode reference, programming, pastebin with syntax highlighting" />
<meta name="robots" content="index, follow" />
<script async src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</head>
<body>
<div class="container"><h1 class="x86-instruction-set-reference">x86 Instruction Set Reference</h1>
<h2>CVTPD2PS - Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values</h2>
<object>
<table>
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
<tr>
<td><code>66 0F 5A /r</code></td>
<td><code>CVTPD2PS xmm1, xmm2/m128 Convert two packed double-precision floating-point values in xmm2/m128 to two packed singleprecision floating-point values in xmm1.</code></td>
<td></td>
</tr>
</table>
</object>
<object>
<table>
<tr>
<th>Description</th>
</tr>
<tr>
<td>
<p>Converts two packed double-precision floating-point values in the source operand (second operand) to two packed single-precision floating-point values in the destination operand (first operand). The source operand can be an XMM register or a 128-bit memory location. The destination operand is an XMM register. The result is stored in the low quadword of the destination operand, and the high quadword is cleared to all 0s. When a conversion is inexact, the value returned is rounded according to the rounding control bits in the MXCSR register.</p>
</td>
</tr>
</table>
</object>
<object>
<table>
<tr>
<th>Operation</th>
</tr>
<tr>
<td>
<pre class="prettyprint">Destination[0..31] = ConvertDoubleToFloat(Source[0..63]);
Destination[32..63] = ConvertDoubleToFloat(Source[64..127]);
Destination[64..127] = 0;
</pre>
</td>
</tr>
</table>
</object>
<object>
<table>
<tr>
<th>SIMD Floating-Point Exceptions</th>
</tr>
<tr>
<td>
<div>
<table>
<tr><td><code>Overflow,</code></td><td>Underflow, Invalid, Precision, Denormal.</td></tr>
</table>
</div>
</td>
</tr>
</table>
</object>
<object>
<table>
<tr>
<th>Protected Mode Exceptions</th>
</tr>
<tr>
<td>
<div>
<table>
<tr><td><code>#GP(0)</code></td><td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments. If a memory operand is not aligned on a 16-byte boundary, regardless of segment.</td></tr>
<tr><td><code>#GP(0)</code></td><td>For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments. If a memory operand is not aligned on a 16-byte boundary, regardless of segment.</td></tr>
<tr><td><code>#SS(0)</code></td><td>For an illegal address in the SS segment.</td></tr>
<tr><td><code>#PF(fault-code)</code></td><td>For a page fault.</td></tr>
<tr><td><code>#NM</code></td><td>If TS in CR0 is set.</td></tr>
<tr><td><code>#XM</code></td><td>If an unmasked SIMD floating-point exception and OSXMMEXCPT in CR4 is 1.</td></tr>
</table>
</div>
</td>
</tr>
</table>
</object>
<object>
<table>
<tr>
<th>Real-Address Mode Exceptions</th>
</tr>
<tr>
<td>
<div>
<table>
<tr><td><code>#GP(0)</code></td><td>If a memory operand is not aligned on a 16-byte boundary, regardless of segment. If any part of the operand lies outside the effective address space from 0 to FFFFH.</td></tr>
<tr><td><code>#GP(0)</code></td><td>If a memory operand is not aligned on a 16-byte boundary, regardless of segment. If any part of the operand lies outside the effective address space from 0 to FFFFH.</td></tr>
<tr><td><code>#NM</code></td><td>If TS in CR0 is set.</td></tr>
<tr><td><code>#XM</code></td><td>If an unmasked SIMD floating-point exception and OSXMMEXCPT in CR4 is 1.</td></tr>
</table>
</div>
</td>
</tr>
</table>
</object>
<object>
<table>
<tr>
<th>Virtual-8086 Mode Exceptions</th>
</tr>
<tr>
<td>
Same exceptions as in Real Address Mode
<div>
<table>
<tr><td><code>#PF(fault-code)</code></td><td>For a page fault.</td></tr>
</table>
</div>
</td>
</tr>
</table>
</object>
<object>
<table>
<tr>
<th>Instruction</th>
<th>Latency</th>
<th>Throughput</th>
<th>Execution Unit</th>
</tr>
<tr><td><code>CPUID</code></td><td>0F3n/0F2n</td><td>0F3n/0F2n</td><td>0F2n</td></tr>
<tr><td><code>CVTPD2PS xmm, xmm</code></td><td>11/10</td><td>2/2</td><td>FP_ADD MMX_SHFT</td></tr>
</table>
</object>
</div>
</body>
</html>
